<?php
/**
 * Generated by Haxe 4.0.0-rc.3+e3df7a4
 */

namespace tink\http;

use \php\_Boot\HxAnon;
use \tink\io\StreamParserObject;
use \php\Boot;
use \tink\url\_Query\QueryStringParser;
use \haxe\io\_BytesData\Container as _BytesDataContainer;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \php\_Boot\HxString;
use \tink\core\OutcomeTools;
use \haxe\ds\StringMap;
use \tink\_Url\Url_Impl_;
use \php\_Boot\HxException;
use \haxe\io\Bytes;
use \php\_NativeIndexedArray\NativeIndexedArrayIterator;
use \tink\core\_Outcome\OutcomeMapper_Impl_;
use \tink\url\_Portion\Portion_Impl_;

class IncomingRequestHeader extends RequestHeader {
	/**
	 * @var StringMap
	 */
	public $cookies;

	/**
	 *  Get a StreamParser which can parse a Source into an IncomingRequestHeader
	 * 
	 * @return StreamParserObject
	 */
	static public function parser () {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:90: lines 90-97
		return new HeaderParser(function ($line, $headers) {
			#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:91: characters 21-36
			$_g = HxString::split($line, " ");
			if ($_g->length === 3) {
				$_g3 = ($_g->arr[2] ?? null);
				$_g1 = ($_g->arr[0] ?? null);
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:93: characters 11-82
				return Outcome::Success(new IncomingRequestHeader($_g1, Url_Impl_::fromString(($_g->arr[1] ?? null)), $_g3, $headers));
			} else {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:95: characters 11-73
				return Outcome::Failure(new TypedError(422, "Invalid HTTP header", new HxAnon([
					"fileName" => "tink/http/Request.hx",
					"lineNumber" => 95,
					"className" => "tink.http.IncomingRequestHeader",
					"methodName" => "parser",
				])));
			}
		});
	}

	/**
	 * @param string $method
	 * @param object $url
	 * @param string $protocol
	 * @param \Array_hx $fields
	 * 
	 * @return void
	 */
	public function __construct ($method, $url, $protocol = null, $fields) {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:35: lines 35-111
		parent::__construct($method, $url, $protocol, $fields);
	}

	/**
	 * @param \Array_hx $fields
	 * 
	 * @return IncomingRequestHeader
	 */
	public function concat ($fields) {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:47: characters 38-44
		$tmp = $this->method;
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:47: characters 46-49
		$tmp1 = $this->url;
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:47: characters 51-59
		$tmp2 = $this->protocol;
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:47: characters 5-88
		return new IncomingRequestHeader($tmp, $tmp1, $tmp2, $this->fields->concat($fields));
	}

	/**
	 *  List all cookie names
	 * 
	 * @return object
	 */
	public function cookieNames () {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:53: characters 12-26
		return new NativeIndexedArrayIterator(array_values(array_map("strval", array_keys($this->cookies->data))));
	}

	/**
	 *  Get the Authorization header as an Enum
	 * 
	 * @return Outcome
	 */
	public function getAuth () {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:65: lines 65-76
		return $this->getAuthWith(function ($s, $p)  use (&$e) {
			if ($s === "Basic") {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:67: characters 9-138
				$decoded = null;
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:67: characters 23-137
				try {
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:67: characters 27-43
					$s1 = base64_decode($p, true);
					$decoded1 = strlen($s1);
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:67: characters 9-138
					$decoded = (new Bytes($decoded1, new _BytesDataContainer($s1)))->toString();
				} catch (\Throwable $__hx__caught_e) {
					$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
					$e = $__hx__real_e;
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:67: characters 72-137
					return Outcome::Failure(TypedError::withData(null, "Error in decoding basic auth", $e, new HxAnon([
						"fileName" => "tink/http/Request.hx",
						"lineNumber" => 67,
						"className" => "tink.http.IncomingRequestHeader",
						"methodName" => "getAuth",
					])));
				}
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:68: characters 16-36
				$_g = HxString::indexOf($decoded, ":");
				if ($_g === -1) {
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:69: characters 20-99
					return Outcome::Failure(new TypedError(null, "Cannot parse username and password because \":\" is missing", new HxAnon([
						"fileName" => "tink/http/Request.hx",
						"lineNumber" => 69,
						"className" => "tink.http.IncomingRequestHeader",
						"methodName" => "getAuth",
					])));
				} else {
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:70: characters 33-53
					$tmp = mb_substr($decoded, 0, $_g);
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:70: characters 19-78
					return Outcome::Success(Authorization::Basic($tmp, mb_substr($decoded, $_g + 1, null)));
				}
			} else if ($s === "Bearer") {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:73: characters 9-27
				return Outcome::Success(Authorization::Bearer($p));
			} else {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:75: characters 9-30
				return Outcome::Success(Authorization::Others($s, $p));
			}
		});
	}

	/**
	 * @param \Closure $parser
	 * 
	 * @return Outcome
	 */
	public function getAuthWith ($parser) {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:79: lines 79-84
		return OutcomeTools::flatMap($this->byName("authorization"), OutcomeMapper_Impl_::withSameError(function ($v)  use (&$parser) {
			#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:79: characters 75-89
			$_g = HxString::indexOf($v, " ");
			if ($_g === -1) {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:81: characters 11-82
				return Outcome::Failure(new TypedError(422, "Invalid Authorization Header", new HxAnon([
					"fileName" => "tink/http/Request.hx",
					"lineNumber" => 81,
					"className" => "tink.http.IncomingRequestHeader",
					"methodName" => "getAuthWith",
				])));
			} else {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:83: characters 18-32
				$tmp = mb_substr($v, 0, $_g);
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:83: characters 11-50
				return $parser($tmp, mb_substr($v, $_g + 1, null));
			}
		}));
	}

	/**
	 *  Get a single cookie
	 * 
	 * @param string $name
	 * 
	 * @return string
	 */
	public function getCookie ($name) {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:59: characters 12-30
		return ($this->getCookies()->data[$name] ?? null);
	}

	/**
	 * @return StringMap
	 */
	public function getCookies () {
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:40: lines 40-41
		if ($this->cookies === null) {
			#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:41: characters 17-131
			$_g = new StringMap();
			#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:41: characters 18-130
			$_g1 = 0;
			$_g2 = $this->get(mb_strtolower("cookie"));
			while ($_g1 < $_g2->length) {
				#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:41: characters 62-92
				$entry = new QueryStringParser(($_g2->arr[$_g1++] ?? null), ";", "=", 0);
				while ($entry->hasNext()) {
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:41: characters 48-130
					$entry1 = $entry->next();
					#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:41: characters 94-130
					$key = $entry1->name;
					$value = Portion_Impl_::toString($entry1->value);
					$_g->data[$key] = $value;
				}
			}

			#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:41: characters 7-131
			$this->cookies = $_g;
		}
		#/home/grabli66/haxelib/tink_http/git/src/tink/http/Request.hx:43: characters 5-19
		return $this->cookies;
	}
}

Boot::registerClass(IncomingRequestHeader::class, 'tink.http.IncomingRequestHeader');
