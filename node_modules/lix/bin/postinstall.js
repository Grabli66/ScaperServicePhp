#! /usr/bin/env node
(function prelude(content, deps, entry) {
  var cache = {}

  function load (file) {
    var d = deps[file]
    if(cache[file]) return cache[file].exports
    if(!d) return require(file)
    var fn = content[d[0]] //the actual module
    var module = cache[file] = {exports: {}, parent: file !== entry}
    cache[file] = module
    var resolved = require('path').resolve(file)
    var dirname = require('path').dirname(resolved)
    fn(
      function (m) {
        if(!d[1][m]) return require(m)
        else         return load (d[1][m])
      },
      module,
      module.exports,
      dirname,
      resolved
    )
    return cache[file].exports
  }

  return load(entry)
})({
"e+p4e3+JVFqPwkg1A0eMl9CI98vY+WAPVoxwO6PI834=":
function (require, module, exports, __dirname, __filename) {



// Generated by Haxe 4.0.0-rc.2+0f9bb3e
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.foreach = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(!f(x1)) {
			return false;
		}
	}
	return true;
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Sys = function() { };
Sys.__name__ = true;
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		var other = _g;
		return other;
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,compare: function(other) {
		var b1 = this.b;
		var b2 = other.b;
		var len = this.length < other.length ? this.length : other.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			if(b1[i] != b2[i]) {
				return b1[i] - b2[i];
			}
		}
		return this.length - other.length;
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g1 = 0;
		var _g2 = this.base.length;
		while(_g1 < _g2) {
			var i1 = _g1++;
			tbl[this.base.b[i1]] = i1;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw new js__$Boot_HaxeError("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
var haxeshim_PostInstall = function() { };
haxeshim_PostInstall.__name__ = true;
haxeshim_PostInstall.makeExe = function(call) {
	var call1 = haxe_io_Bytes.ofString(call);
	var replacer = new haxe_io_Bytes(new ArrayBuffer(haxeshim_PostInstall.placeholder.length));
	replacer.fill(0,replacer.length,0);
	replacer.blit(0,call1,0,call1.length);
	var buf = new haxe_io_Bytes(new ArrayBuffer(haxeshim_PostInstall.exifier.length));
	buf.blit(0,haxeshim_PostInstall.exifier,0,buf.length);
	buf.blit(haxeshim_PostInstall.offset,replacer,0,replacer.length);
	return buf;
};
haxeshim_PostInstall.exify = function(dir,source,mayFail) {
	var name = "haxe";
	var exe = "" + dir + "/" + name + ".exe";
	if(sys_FileSystem.exists(exe) && !sys_FileSystem.exists("" + exe + ".bak")) {
		js_node_Fs.renameSync(exe,"" + exe + ".bak");
	}
	try {
		var bytes = haxeshim_PostInstall.makeExe("node \"" + source + "/" + name + "shim.js\"");
		var data = bytes.b;
		js_node_Fs.writeFileSync(exe,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,bytes.length));
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		if(!mayFail(name)) {
			process.stdout.write(Std.string("failed to shim " + name));
			process.stdout.write("\n");
			process.exit(500);
		}
	}
	var name1 = "haxelib";
	var exe1 = "" + dir + "/" + name1 + ".exe";
	if(sys_FileSystem.exists(exe1) && !sys_FileSystem.exists("" + exe1 + ".bak")) {
		js_node_Fs.renameSync(exe1,"" + exe1 + ".bak");
	}
	try {
		var bytes1 = haxeshim_PostInstall.makeExe("node \"" + source + "/" + name1 + "shim.js\"");
		var data1 = bytes1.b;
		js_node_Fs.writeFileSync(exe1,js_node_buffer_Buffer.from(data1.buffer,data1.byteOffset,bytes1.length));
	} catch( e2 ) {
		var e3 = ((e2) instanceof js__$Boot_HaxeError) ? e2.val : e2;
		if(!mayFail(name1)) {
			process.stdout.write(Std.string("failed to shim " + name1));
			process.stdout.write("\n");
			process.exit(500);
		}
	}
	var name2 = "neko";
	var exe2 = "" + dir + "/" + name2 + ".exe";
	if(sys_FileSystem.exists(exe2) && !sys_FileSystem.exists("" + exe2 + ".bak")) {
		js_node_Fs.renameSync(exe2,"" + exe2 + ".bak");
	}
	try {
		var bytes2 = haxeshim_PostInstall.makeExe("node \"" + source + "/" + name2 + "shim.js\"");
		var data2 = bytes2.b;
		js_node_Fs.writeFileSync(exe2,js_node_buffer_Buffer.from(data2.buffer,data2.byteOffset,bytes2.length));
	} catch( e4 ) {
		var e5 = ((e4) instanceof js__$Boot_HaxeError) ? e4.val : e4;
		if(!mayFail(name2)) {
			process.stdout.write(Std.string("failed to shim " + name2));
			process.stdout.write("\n");
			process.exit(500);
		}
	}
};
haxeshim_PostInstall.which = function(name) {
	return Std.string(js_node_ChildProcess.spawnSync(haxeshim_PostInstall.WINDOWS ? "where" : "which",[name]).stdout).split("\n").map(StringTools.trim);
};
haxeshim_PostInstall.main = function() {
	if(haxeshim_PostInstall.GLOBAL) {
		if(haxeshim_PostInstall.WINDOWS) {
			var sources = StringTools.replace(__dirname,"\\","/");
			var args = ["--run","show-version"];
			var mayFail = (args == null ? js_node_ChildProcess.spawnSync("haxe",{ shell : true, stdio : "inherit"}).status : js_node_ChildProcess.spawnSync("haxe",args,{ stdio : "inherit"}).status) == 0 ? function(c) {
				return c == "haxe";
			} : function(_) {
				return false;
			};
			var _g1 = 0;
			var _g2 = haxeshim_PostInstall.which("haxe");
			while(_g1 < _g2.length) {
				var p = _g2[_g1];
				++_g1;
				var _g11 = new haxe_io_Path(p);
				var _g5 = _g11.backslash;
				var _g4 = _g11.ext;
				var _g3 = _g11.file;
				var _g21 = _g11.dir;
				if(_g4 != null) {
					switch(_g4) {
					case "cmd":
						var npm = _g21;
						haxeshim_PostInstall.exify(npm,sources,mayFail);
						break;
					case "exe":
						var std = [_g21];
						if(Lambda.foreach(["CHANGES.txt","CONTRIB.txt","LICENSE.txt"],(function(std1) {
							return function(file) {
								return sys_FileSystem.exists("" + std1[0] + "/" + file);
							};
						})(std))) {
							haxeshim_PostInstall.exify(std[0],sources,mayFail);
						}
						break;
					default:
					}
				}
			}
		}
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
		return false;
	}
};
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else if (typeof o == 'string') return HxOverrides.strIter(o); else return o.iterator(); }
String.__name__ = true;
Array.__name__ = true;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxeshim_PostInstall.placeholder = haxe_io_Bytes.ofString("abcdefghijklmnopqrstufvwxyzABCDEFGHIJKLMNOPQRSTUFVWXYZ0123456789abcdefghijklmnopqrstufvwxyzABCDEFGHIJKLMNOPQRSTUFVWXYZ0123456789abcdefghijklmnopqrstufvwxyzABCDEFGHIJKLMNOPQRSTUFVWXYZ0123456789abcdefghijklmnopqrstufvwxyzABCDEFGHIJKLMNOPQRSTUFVWXYZ0123456789");
haxeshim_PostInstall.exifier = haxe_crypto_Base64.decode("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");
haxeshim_PostInstall.offset = (function($this) {
	var $r;
	var ret = -1;
	{
		var _g = 0;
		var _g1 = haxeshim_PostInstall.exifier.length - haxeshim_PostInstall.placeholder.length;
		while(_g < _g1) {
			var i = _g++;
			if(haxeshim_PostInstall.exifier.sub(i,haxeshim_PostInstall.placeholder.length).compare(haxeshim_PostInstall.placeholder) == 0) {
				ret = i;
				break;
			}
		}
	}
	if(ret == -1) {
		throw new js__$Boot_HaxeError("no placeholder found");
	}
	$r = ret;
	return $r;
}(this));
haxeshim_PostInstall.GLOBAL = !(!process.env["npm_config_global"]);
haxeshim_PostInstall.WINDOWS = Sys.systemName() == "Windows";
haxeshim_PostInstall.main();
})({});

},

}
,
{
  "bin/postinstall.js": [
    "e+p4e3+JVFqPwkg1A0eMl9CI98vY+WAPVoxwO6PI834=",
    {}
  ]
},
"bin/postinstall.js")
